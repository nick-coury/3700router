#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy
from concurrent.futures.process import _MAX_WINDOWS_WORKERS


class Router:
    # enum: cust | prov | peer
    relations = {}

    # list of UDP sockets 
    sockets = {}

    # list of ports in router, each port has a UDP socket 
    ports = {}

    # forwarding table holds key, value 
    # key - ip address of source
    # value - dictionary:  
    #               - "network":    "<network prefix>",             # Example: 12.0.0.0
    #               - "netmask":    "<associated subnet netmask>",  # Example: 255.0.0.0
    #               - "localpref":  "<integer>",                    # Example: 100
    #               - "selfOrigin": "<true|false>",
    #               - "ASPath":     "{<nid>, [nid], ...}",          # Examples: [1] or [3, 4] or [1, 4, 3]
    #               - "origin":     "<IGP|EGP|UNK>"            (ip address of destination network , destination network netmask)
    fwd_table = {}

    # list of update messages received by the router 
    announcements = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation

            # print("Router IP", neighbor)
            # print("Sockets", self.sockets)
            # print("Ports", self.ports)

            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def update_fwd_table(self, update_msg_dict):
        self.fwd_table[update_msg_dict["src"]] = update_msg_dict["msg"]

        # DEBUG
        # print("---updated fwd table---")
        # self.print_table()
        
    def print_table(self):    
        print("------TABLE-------")
        print(self.fwd_table)
        print("------------------")
        

    def update(self, msg_dict):
        # save a copy of the announcement from the neighbor 
        self.announcements[msg_dict["src"]] = copy.deepcopy(msg_dict)
        # add entry to fwd table
        self.update_fwd_table(msg_dict)

        print(self.fwd_table)

        # Remove private info from the message 
        extracted_network_msg = copy.deepcopy(msg_dict["msg"])
        del extracted_network_msg["origin"]
        del extracted_network_msg["selfOrigin"]
        del extracted_network_msg["localpref"]

        # add ourselves to the ASPath 
        extracted_network_msg["ASPath"].insert(0, self.asn)

        print(self.fwd_table)

        received_from = "0"
        # Obtain the relation from the recieved message
        for n in self.sockets:
            if n == msg_dict["src"]:
                received_from = n
                break
            if received_from == 0:
                raise Exception("No match from received message")

        # Update received from a customer: send updates to all other neighbors
        if(self.relations[received_from] == "cust"):
            for n in self.sockets:
                # so we don't send a message back to where it came from
                if(n != received_from):
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "update",     
                    "msg": extracted_network_msg 
                    })
                    self.send(n, new_msg)
        # Update received from a peer or a provider: only send updates to your customers
        else:
            for n in self.sockets:
                if self.relations[n] == "cust":
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "update",     
                    "msg": extracted_network_msg 
                    })
                    self.send(n, new_msg)

    def data(self, msg_dict):
        # in the future this will be where we handle data forwarding logic 
        # if our router hears a data message,  source is the dst in the fwd table
        
        # new serialized data message to send 
        new_msg = json.dumps({"src": msg_dict["src"], 
                "dst": msg_dict["dst"],  
                "type": "data", 
                "msg": msg_dict["msg"],
        })
        
        # Select best network
        no_match = True
        for n in self.fwd_table:
            dict_quads = list(int(qdn) for qdn in msg_dict["dst"].split('.'))
            temp = self.fwd_table[n]
            fwd_quads = list(int(qdn) for qdn in temp["network"].split('.'))
            if (dict_quads[0] == fwd_quads[0]):
                # Send message to network
                self.send(n, new_msg)
                no_match = False
                break
        if no_match:
            for n in self.fwd_table:
                dict_quads_back= list(int(qdn) for qdn in msg_dict["src"].split('.'))
                temp = self.fwd_table[n]
                fwd_quads_back = list(int(qdn) for qdn in temp["network"].split('.'))
                if(dict_quads_back[0] == fwd_quads_back[0]):
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": msg_dict["src"], 
                    "type": "no route", 
                    "msg": {},
                    })
                    #print("we are sending a no route to: ", n)
                    self.send(n, new_msg)
                    break

    def dump(self, msg_dict):
        # new serialized table message to send back
        self.print_table()
        new_msg = []
        for n in self.fwd_table:
            new_entry = self.fwd_table[n].copy()
            new_entry["peer"] = n
            new_msg.append(new_entry)
        
        table_msg = json.dumps({"src": msg_dict["dst"], 
        "dst": msg_dict["src"], # the message's new destination is the original message's source 
        "type": "table", 
        "msg": new_msg,
        })
        #print("XXXXXX ", new_msg)
        self.send(msg_dict["src"], table_msg)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                # a specific message for the current socket in the list of sockets 
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                msg_dict = json.loads(msg)

                # Choose what to do with the received messaged based on the type
                # if an update message, copy, add to fwd, send to neighbors
                if(msg_dict["type"] == "update"):
                    self.update(msg_dict)
                # if a data message, forward (send) the message to its dest    
                elif(msg_dict["type"] == "data"):
                    self.data(msg_dict)
                # if a dump message, reply with our forwarding table
                elif(msg_dict["type"] == "dump"):
                    self.dump(msg_dict)
                    
        return
    

# Recieved 
# 192.168.0.25 
# To compare >> binary, compare with table in binary + netmask

# Table
# 192.168.0.1 << 255.255.255.0
# 172.168.0.1 << 255.255.0.0

# {'src': '192.168.0.2', 'dst': '192.168.0.1', 'type': 'update', 'msg': {'network': '192.168.0.0', 'netmask': '255.255.255.0', 'ASPath': [1]}}
# {'msg': {'netmask': '255.255.255.0', 'ASPath': [14, 1], 'network': '192.168.0.0'}, 'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update'}

# {"src": "192.168.0.2", "dst": "192.168.0.1", "type": "update", "msg": {"network": "192.168.0.0", "netmask": "255.255.255.0", "ASPath": [1]}}

# From peer 172
# Expected {'msg': {'netmask': '255.255.255.0', 'ASPath': [14, 1], 'network': '192.168.0.0'}, 'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update'}
# Recevied {'src': '192.168.0.1', 'dst': '192.168.0.2', 'type': 'update', 'msg': {'network': '192.168.0.0', 'netmask': '255.255.255.0', 'ASPath': [14, 1]}}

# Peer 192.168.0.2 did not receive expected route announcement {'msg': {'netmask': '255.255.0.0', 'ASPath': [14, 2], 'network': '172.168.0.0'}, 'src': '192.168.0.1', 'dst': '192.168.0.2', 'type': 'update'}
# Peer 192.168.0.2 received unexpected route announcement      {'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update', 'msg': {'network': '172.168.0.0', 'netmask': '255.255.0.0', 'ASPath': [14, 2]}}

# ours: '{'network': '172.168.0.0', 'netmask': '255.255.0.0', 'localpref': 100, 'ASPath': [14, 2], 'origin': 'EGP', 'selfOrigin': True, 'peer': '172.168.0.2'}'
# want: '{'origin': 'EGP', 'localpref': 100, 'network': '172.168.0.0', 'ASPath': [2], 'netmask': '255.255.0.0', 'peer': '172.168.0.2', 'selfOrigin': True}'

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
