#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy
from concurrent.futures.process import _MAX_WINDOWS_WORKERS
from tkinter.tix import INTEGER


class Router:
    # enum: cust | prov | peer
    relations = {}

    # list of UDP sockets 
    sockets = {}

    # list of ports in router, each port has a UDP socket 
    ports = {}

    # forwarding table holds an array of dictionaries {key : value}
    # key - ip address of source
    # value - dictionary:  
    #               - "network":    "<network prefix>",             # Example: 12.0.0.0
    #               - "netmask":    "<associated subnet netmask>",  # Example: 255.0.0.0
    #               - "localpref":  "<integer>",                    # Example: 100
    #               - "selfOrigin": "<true|false>",
    #               - "ASPath":     "{<nid>, [nid], ...}",          # Examples: [1] or [3, 4] or [1, 4, 3]
    #               - "origin":     "<IGP|EGP|UNK>"            (ip address of destination network , destination network netmask)
    fwd_table = []

    # list of update messages received by the router 
    announcements = []

    # list of withdraw messages
    revocations = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation

            # print("Router IP", neighbor)
            # print("Sockets", self.sockets)
            # print("Ports", self.ports)

            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # def update_fwd_table(self, update_msg_dict):
    #     self.fwd_table.append(update_msg_dict)
    #     #[update_msg_dict["src"]] = update_msg_dict["msg"]

    #     # DEBUG
    #     #print("---updated fwd table---")
    #     self.print_table()
        
    def print_table(self):    
        print("------TABLE-------")
        print(self.fwd_table)
        print("------------------")

    #   1. The entry with the highest localpref wins. If the localprefs are equal
    #   2. The entry with selfOrigin as true wins. If all selfOrigins are the equal
    #   3. The entry with the shortest ASPath wins. If multiple entries have the shortest length
    #   4. The entry with the best origin wins, were IGP > EGP > UNK. If multiple entries have the best origin
    #   5. The entry from the neighbor router (i.e., the src of the update message) with the lowest IP address
    def get_best_ip(self, matching_ips):
        best_ip_dict = matching_ips[0]
        best_ip = best_ip_dict["peer"]

        for curr_ip_dict in matching_ips:
            curr_ip = curr_ip_dict["peer"]

            # check which aspect is better, only move on if they're both equal 
            # check the local prefs of the two messages 
            if(best_ip_dict["localpref"] < curr_ip_dict["localpref"]): 
                best_ip = curr_ip
            elif(best_ip_dict["localpref"] > curr_ip_dict["localpref"]): 
                best_ip = best_ip
            
            # check the self origins of both messages 
            elif(best_ip_dict["selfOrigin"] == False and curr_ip_dict["selfOrigin"] == True): # make sure 1: true 2: false 
                best_ip = curr_ip
            elif(best_ip_dict["selfOrigin"] == True and curr_ip_dict["selfOrigin"] == False): # make sure 1: false 2: true 
                best_ip = best_ip
            
            # check the aspaths of both messages 
            elif(len(best_ip_dict["ASPath"]) > len(curr_ip_dict["ASPath"])):
                best_ip = curr_ip    
            elif(len(best_ip_dict["ASPath"]) < len(curr_ip_dict["ASPath"])):
                best_ip = best_ip  
            
            # check they do not have the same origin and make sure the 
            elif((best_ip_dict["origin"] != "IGP" and curr_ip_dict == "IGP") or (best_ip_dict["origin"] == "UNK" and curr_ip_dict["origin"] == "EGP")):
                best_ip = curr_ip
            elif((curr_ip_dict["origin"] != "IGP" and best_ip_dict == "IGP") or (curr_ip_dict["origin"] == "UNK" and curr_ip_dict["origin"] == "EGP")):
                best_ip = best_ip
            
            # catch all, if equal, send the global best ip (should never happen)
            elif(best_ip > curr_ip):
                best_ip = curr_ip
        return best_ip
        

    def update(self, msg_dict, srcif):
        # save a copy of the announcement from the neighbor 
        self.announcements.append(copy.deepcopy(msg_dict))
        # add entry to fwd table
        new_entry = copy.deepcopy(msg_dict["msg"])
        new_entry["peer"] = msg_dict["src"]
        self.fwd_table.append(new_entry)

        # Remove private info from the message 
        extracted_network_msg = copy.deepcopy(msg_dict["msg"])
        del extracted_network_msg["origin"]
        del extracted_network_msg["selfOrigin"]
        del extracted_network_msg["localpref"]

        # add ourselves to the ASPath 
        extracted_network_msg["ASPath"].insert(0, self.asn)

        # received_from = "0"
        # # Obtain the relation from the recieved message
        # for n in self.sockets:
        #     if n == msg_dict["src"]:
        #         received_from = n
        #         break
        #     if received_from == 0:
        #         raise Exception("No match from received message")

        # Update received from a customer: send updates to all other neighbors
        if(self.relations[srcif] == "cust"):
            for n in self.sockets:
                # so we don't send a message back to where it came from
                if(n != srcif):
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "update",     
                    "msg": extracted_network_msg 
                    })
                    self.send(n, new_msg)
        # Update received from a peer or a provider: only send updates to your customers
        else:
            for n in self.sockets:
                if self.relations[n] == "cust":
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "update",     
                    "msg": extracted_network_msg 
                    })
                    self.send(n, new_msg)

        #self.print_table()

    # network comes in as [XXXX.XXXX.XXXX.XXXX] -> 10101010101010101010 <- 4 quads worth of binary in str form
    def to_binary(self, network):
        str_bin_network = ""
        quads = list(int(qdn) for qdn in network.split('.'))

        # Transform each quad into binary
        first_quad = str(bin(quads[0]))
        first_final =  first_quad[2:len(first_quad)].zfill(8)

        second_quad = str(bin(quads[1]))
        second_final = second_quad[2:len(second_quad)].zfill(8)

        third_quad = str(bin(quads[2]))
        third_final = third_quad[2:len(third_quad)].zfill(8)

        fourth_quad = str(bin(quads[3]))
        fourth_final = fourth_quad[2:len(fourth_quad)].zfill(8)

        str_bin_network = first_final + second_final + third_final + fourth_final

        return str_bin_network
        
    
    # Given a string binary netmask, return the number of 1's in the list
    # returns the /X number in CIDR addresses 
    def get_cidr_len(self, netmask):
        ones = 0
        for bit in netmask:
            if bit == "1":
                ones += 1
        return ones
    
    # network comes in as [123.123.123.123] [255.255.0.0] -> [bin bin 0 0] (netmasked ip)
    def netmask_this(self, network, netmask): 
        network_bin = self.to_binary(network)
        netmask_bin = self.to_binary(netmask)
        final = ""
        for i in range(32):
            if network_bin[i] == 1 and netmask_bin[i] == 1:
                final += "1"
            else: 
                final += "0"
        return final

    # print(str(10).zfill(4))
    # Expected output: "0010"

    # Takes in a destination ip and returns a list of ALL matching ips with the longest matching prefix
    def longest_prefix_match(self, dst):
        # loop through the fwd table 
        #   if dest corresponds to current fwd table entry's network + netmask
        #       find the longest prefix
        #       if shorter than longest prefix -> don't add to list
        #       if equal to longest prefix -> add to list
        #       if longer than longest prefix -> drop current list, start new one
        matching_ips = []
        longest_prefix_length = 0
        for n in self.fwd_table:
            cidr_len = self.get_cidr_len(n["netmask"])
            if self.netmask_this(dst, n["netmask"])[0:cidr_len] == self.netmask_this(n["network"], n["netmask"])[0:cidr_len]:
                if cidr_len == longest_prefix_length:
                    matching_ips.append(copy.deepcopy(n))
                elif cidr_len > longest_prefix_length:
                    longest_prefix_length = cidr_len
                    matching_ips = []
                    matching_ips.append(copy.deepcopy(n))
        print("------ matching ips: ", matching_ips)
        return matching_ips

    def data(self, msg_dict, srcif):
        # in the future this will be where we handle data forwarding logic 
        # if our router hears a data message,  source is the dst in the fwd table

        matching_ips = []
        
        # new serialized data message to send 
        new_msg = json.dumps({"src": msg_dict["src"], 
                "dst": msg_dict["dst"],  
                "type": "data", 
                "msg": msg_dict["msg"],
        })
        
        # Select best network
        #   0. Longest prefix match
        #self.print_table()
        # no_match = True
        # for n in self.fwd_table:
        #     dict_quads = list(int(qdn) for qdn in msg_dict["dst"].split('.'))
        #     temp = n
        #     fwd_quads = list(int(qdn) for qdn in temp["network"].split('.'))
        #     if (dict_quads[0] == fwd_quads[0]):
        #         # Send message to network
        #         # add the matched network to the list of matching IP's
        #         matching_ips.append(n) # = self.fwd_table[n]
        #         no_match = False
        # # if no match and legal to forward then send         
        matching_ips = self.longest_prefix_match(msg_dict["dst"])
        if len(matching_ips) != 0:  
            final_ip = self.get_best_ip(matching_ips)

            if ((self.relations[srcif] == "cust") or (self.relations[final_ip] == "cust")) :
                self.send(final_ip, new_msg)
        else:
            # for n in self.fwd_table:
            #     dict_quads_back= list(int(qdn) for qdn in msg_dict["src"].split('.'))
            #     temp = n #self.fwd_table[n]
            #     fwd_quads_back = list(int(qdn) for qdn in temp["network"].split('.'))
            #     if(dict_quads_back[0] == fwd_quads_back[0]):
            #         matching_ips.append(n)

            # final_ip = self.get_best_ip(matching_ips)
            #print("-----------------NOMATCH------------------------------")
            new_msg = json.dumps({"src": self.our_addr(srcif), 
            "dst": msg_dict["src"], 
            "type": "no route", 
            "msg": {},
            })
            #print("we are sending a no route to: ", n)
            self.send(srcif, new_msg)
        

    def dump(self, msg_dict):
        table_msg = json.dumps({"src": msg_dict["dst"], 
        "dst": msg_dict["src"], # the message's new destination is the original message's source 
        "type": "table", 
        "msg": self.fwd_table,
        })
        #print("XXXXXX ", new_msg)
        self.send(msg_dict["src"], table_msg)

    def withdraw(self, msg_dict, srcif):
        # First save a copy of the withdraw message 
        self.revocations.append(copy.deepcopy(msg_dict))

        # Next update the forwarding table by removing all networks in the fwd_table inside the msg_dict
        rmv_list = copy.deepcopy(msg_dict["msg"])
        for to_remove in rmv_list:
            for n in self.fwd_table:
                if n["peer"] == msg_dict["src"] and n["netmask"] == to_remove["netmask"] and n["network"] == to_remove["network"]:
                    self.fwd_table.remove(n)

        # Revocation received from a customer: send updates to all other neighbors
        if(self.relations[srcif] == "cust"):
            for n in self.sockets:
                # so we don't send a message back to where it came from
                if(n != srcif):
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "withdraw",
                    "msg": msg_dict["msg"]
                    })
                    self.send(n, new_msg)
        # Revocation received from a peer or a provider: only send updates to your customers
        else:
            for n in self.sockets:
                if self.relations[n] == "cust":
                    new_msg = json.dumps({"src": self.our_addr(n), 
                    "dst": n, 
                    "type": "witdraw",     
                    "msg": msg_dict["msg"]
                    })
                    self.send(n, new_msg)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                # a specific message for the current socket in the list of sockets 
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                msg_dict = json.loads(msg)

                # Choose what to do with the received messaged based on the type
                # if an update message, copy, add to fwd, send to neighbors
                if(msg_dict["type"] == "update"):
                    self.update(msg_dict, srcif)
                # if a data message, forward (send) the message to its dest    
                elif(msg_dict["type"] == "data"):
                    self.data(msg_dict, srcif)
                # if a dump message, reply with our forwarding table
                elif(msg_dict["type"] == "dump"):
                    self.dump(msg_dict)
                elif(msg_dict["type"] == "withdraw"):
                    self.withdraw(msg_dict, srcif)             
    

# Recieved 
# 192.168.0.25 
# To compare >> binary, compare with table in binary + netmask

# Table
# 192.168.0.1 << 255.255.255.0
# 172.168.0.1 << 255.255.0.0

# {'src': '192.168.0.2', 'dst': '192.168.0.1', 'type': 'update', 'msg': {'network': '192.168.0.0', 'netmask': '255.255.255.0', 'ASPath': [1]}}
# {'msg': {'netmask': '255.255.255.0', 'ASPath': [14, 1], 'network': '192.168.0.0'}, 'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update'}

# {"src": "192.168.0.2", "dst": "192.168.0.1", "type": "update", "msg": {"network": "192.168.0.0", "netmask": "255.255.255.0", "ASPath": [1]}}

# From peer 172
# Expected {'msg': {'netmask': '255.255.255.0', 'ASPath': [14, 1], 'network': '192.168.0.0'}, 'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update'}
# Recevied {'src': '192.168.0.1', 'dst': '192.168.0.2', 'type': 'update', 'msg': {'network': '192.168.0.0', 'netmask': '255.255.255.0', 'ASPath': [14, 1]}}

# Peer 192.168.0.2 did not receive expected route announcement {'msg': {'netmask': '255.255.0.0', 'ASPath': [14, 2], 'network': '172.168.0.0'}, 'src': '192.168.0.1', 'dst': '192.168.0.2', 'type': 'update'}
# Peer 192.168.0.2 received unexpected route announcement      {'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update', 'msg': {'network': '172.168.0.0', 'netmask': '255.255.0.0', 'ASPath': [14, 2]}}

# ours: '{'network': '172.168.0.0', 'netmask': '255.255.0.0', 'localpref': 100, 'ASPath': [14, 2], 'origin': 'EGP', 'selfOrigin': True, 'peer': '172.168.0.2'}'
# want: '{'origin': 'EGP', 'localpref': 100, 'network': '172.168.0.0', 'ASPath': [2], 'netmask': '255.255.0.0', 'peer': '172.168.0.2', 'selfOrigin': True}'

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
