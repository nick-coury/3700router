#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from concurrent.futures.process import _MAX_WINDOWS_WORKERS


class Router:
    # enum: CUST | PROV | PEER
    relations = {}

    # list of UDP sockets 
    sockets = {}

    # list of ports in router, each port has a UDP socket 
    ports = {}

    # forwarding table holds key, value 
    # key - ip address of source
    # value - dictionary:  
    #               - "network":    "<network prefix>",             # Example: 12.0.0.0
    #               - "netmask":    "<associated subnet netmask>",  # Example: 255.0.0.0
    #               - "localpref":  "<integer>",                    # Example: 100
    #               - "selfOrigin": "<true|false>",
    #               - "ASPath":     "{<nid>, [nid], ...}",          # Examples: [1] or [3, 4] or [1, 4, 3]
    #               - "origin":     "<IGP|EGP|UNK>"            (ip address of destination network , destination network netmask)
    fwd_table = {}

    # list of update messages received by the router 
    announcements = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation

            #print(type (neighbor))
            print("Router IP", neighbor)
            print("Sockets", self.sockets)
            print("Ports", self.ports)

            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        #print("send method's network: ", network)
        #print("send method's message: ", message)

        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def update_fwd_table(self, update_msg_dict):
        #do something
        self.fwd_table[update_msg_dict["src"]] = update_msg_dict["msg"]
        print("---updated fwd table---")
        self.print_table()
        
    def print_table(self):    
        print("------TABLE-------")
        print(self.fwd_table)
        print("------------------")
        

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                # a specific message for the current socket in the list of sockets 
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                msg_dict = json.loads(msg)

                # Choose what to do with the received messaged based on the type

                # if an update message
                if(msg_dict["type"] == "update"):
                    # save a copy of the announcement from the neighbor 
                    self.announcements[msg_dict["src"]] = msg_dict.copy()
                    # add entry to fwd table
                    self.update_fwd_table(msg_dict)
                    # send copy of announcement to neighbors 
                     
                    # Rebroadcast the message to the neighbors 
                    #   Update received from a customer: send updates to all other neighbors
                    #   Update received from a peer or a provider: only send updates to your customers
                
                    # new serialized table message to send back
                    print("BROADCASTING TO NEIGHBORS")

                    extracted_network_msg = msg_dict["msg"]
                    del extracted_network_msg["origin"]
                    del extracted_network_msg["selfOrigin"]
                    del extracted_network_msg["localpref"]

                    # add ourselves to the ASPath 
                    extracted_network_msg["ASPath"].insert(0, self.asn)
                    
                    # print("NEW MESSAGE: " , extracted_network_msg)
                    new_msg = json.dumps({"src": msg_dict["dst"], 
                        "dst": msg_dict["src"], # the message's new destination is the original message's source 
                        "type": "update",     
                        "msg": extracted_network_msg 
                    })

                    received_from = "0"
                    # Obtain the relation from the recieved message
                    for n in self.sockets:
                        if n == msg_dict["src"]:
                            received_from = n
                            break
                        if received_from == 0:
                            raise Exception("No match from received message")

                    # Update received from a customer: send updates to all other neighbors
                    if(self.relations[received_from] == "CUST"):
                        for n in self.sockets:
                            # so we don't send a message back to where it came from
                            if(n != received_from):
                                self.send(n, new_msg)
                    # Update received from a peer or a provider: only send updates to your customers
                    else:
                        for n in self.sockets:
                            if self.relations[n] == "CUST":
                                self.send(n, new_msg)

                # if a data message, forward (send) the message to its dest    
                elif(msg_dict["type"] == "data"):
                    # in the future this will be where we handle data forwarding logic 
                    # if our router hears a data message,  source is the dst in the fwd table
                   
                    # new serialized data message to send 
                    new_msg = json.dumps({"src": msg_dict["src"], 
                          "dst": msg_dict["dst"], # the message's new destination is the original message's source 
                          "type": "data", 
                          "msg": msg_dict["msg"],
                      }).encode('utf-8')

                    self.print_table()
                    
                    self.send(msg_dict["dst"], new_msg)
                    # self.send("%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3]), msg_dict["msg"])

                # if a dump message, reply with our forwarding table
                elif(msg_dict["type"] == "dump"):

                    # new serialized table message to send back
                    new_msg = json.dumps({"src": msg_dict["dst"], 
                          "dst": msg_dict["src"], # the message's new destination is the original message's source 
                          "type": "table", 
                          "msg": self.fwd_table,
                      }).encode('utf-8')
                    self.send(msg_dict["src"], new_msg)
                    
        return
    

# Recieved 
# 192.168.0.25 
# To compare >> binary, compare with table in binary + netmask

# Table
# 192.168.0.1 << 255.255.255.0
# 172.168.0.1 << 255.255.0.0

# {'src': '192.168.0.2', 'dst': '192.168.0.1', 'type': 'update', 'msg': {'network': '192.168.0.0', 'netmask': '255.255.255.0', 'ASPath': [1]}}
# {'msg': {'netmask': '255.255.255.0', 'ASPath': [14, 1], 'network': '192.168.0.0'}, 'src': '172.168.0.1', 'dst': '172.168.0.2', 'type': 'update'}

# {"src": "192.168.0.2", "dst": "192.168.0.1", "type": "update", "msg": {"network": "192.168.0.0", "netmask": "255.255.255.0", "ASPath": [1]}}

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
